===================
Zajęcia 12: exploit
===================

Data: 13.05.2014, 15.05.2014

.. toctree::
   :hidden:

   zadanie


Materiały dodatkowe
===================

- :ref:`12-zadanie`
- :download:`exploit.tar.bz2`


Stos programu
=============

Każdy proces ma, dostarczany przez system operacyjny, stos. Nie jest on
niczym innym jak zamapowanym, ciągłym fragmentem przestrzeni adresowej
procesu oraz ustawionym rejestrem stosu (na potrzeby scenariusza - SP).
Na stosie odkładane są zmienne lokalne, adresy powrotu wykonywanych w danej
chwili funkcji oraz częściowe wyniki obliczeń.

Implementacja operacji jest trywialna:

- położenie danych na stos to zapis do pamięci wskazywanej przez rejestr SP i
  modyfikacja tego rejestru o rozmiar zapisanych danych
- zdjęcie danych ze stosu to odczyt spod SP i modyfikacja SP o rozmiar
  zdejmowanych danych

System operacyjny mapuje programom z góry ustaloną ilość pamięci na stos
(rzędu 2 stron) a kolejne strony pamięci alokuje dopiero, gdy zachodzi taka
potrzeba.

i386
----

Na potrzeby tego scenariusza skupimy się na architekturze i386:

- SP wskazuje na bajt który jest na czubku stosu
- stos rośnie w dół, czyli położenie danych na stos oznacza zmniejszenie SP
- na Linuksie i BSD wołający funkcję powinien (w klasycznym przypadku, więcej w [1]):

  - zachować zawartość rejestrów innych niż BP, SI, DI, BX (jeżeli będzie
    chciał ich potem użyć)
  - położyć na stos argumenty w odwrotnej kolejności niż w deklaracji funkcji
  - skoczyć do treści wołanej funkcji kładąc na stos aktualne miejsce w
    kodzie programu (adres powrotu)
  - po powrocie wołanej funkcji - zdjąć ze stosu argumenty (wynik jest w AX)

- wołany powinien

  - zachować rejestry BP, SI, DI, BX, jeżeli zamierza je zmienić
  - opcjonalnie ustawić rejestr BP na zawartość SP (potrzebne do uzyskania
    stack-trace'ów, upraszcza kod w asemblerze, ale nie jest obowiązkowe, w
    gcc można wyłączyć generowanie takiego kodu za pomocą flagi
    ``-fomit-frame-pointer``)
  - zarezerwować miejsce na stosie na zmienne lokalne (przesuwając SP)
  - wykonać swoją treść
  - odtworzyć rejestry
  - do AX wpisać wynik
  - skoczyć pod adres z czubka stosu - adres powrotu, ten położony przez
    wołającego

Wady i zalety stosu
-------------------

Jak widać z tego scenariusza alokacja zmiennych lokalnych jest bardzo szybka,
ponieważ sprowadza się do modyfikacji jednego rejestru i o ile zmienne
lokalne są wielokrotnościami rozmiaru słowa procesora, to nie istnieje
problem fragmentacji. Te dwie cechy dają alokacji na stosie dużą przewagę nad
alokacją na stercie - malloc musi mieć złożoną logikę zarządzania pamięcią i
do tego trudno uniknąć fragmentacji. Niemniej, stos nie nadaje się do
trzymania zmiennych, których cykl życia przekracza jedno wywołanie funkcji.

Inną cechą stosu jest łatwość przewidzenia ułożenia danych programu na nim i
w przypadku błędnie napisanego programu wykorzystania tej wiedzy do przejęcia
kontroli nad programem.

Buffer overflow
===============

Takim mianem określa się sytuację, kiedy z jakichś powodów program "zapomina"
o faktycznym rozmiarze jakiegoś bufora i przekracza jego granice dostając się
do pamięci do niego nienależącej. Przykład::

   char c[5];
   strcpy(c, "12345");

``strcpy()`` kopiuje napis do bufora przekazanego jako pierwszy argument razem z
kończącym zerem, zatem w tym przypadku 6 znaków do 5-elementowego bufora.

Specyfikacja języka na ogół nic o tym nie mówi, ale kompilatory zachowują się
przewidywalnie i można łatwo odgadnąć jak zmienne leżą względem siebie na
stosie (na ogół po kolei). Taka sytuacja powoduje, że szczególny przypadek
przepełnienia bufora - stack buffer overflow, można łatwo wykorzystać,
ponieważ przekraczając granicę bufora wystarczająco, można nadpisać adres
powrotu z funkcji. Jeżeli zrobi się to umiejętnie, to można przejąć kontrolę
nad programem, ponieważ mnemonik ret w kodzie atakowanego programu doprowadzi
do skoku w miejsce wpisane w adres powrotu.

inetd
-----

``inetd`` jest standardowym uniksowym demonem, tzw. superserwerem. W pliku
konfiguracyjnym ``inetd.conf`` przypisuje się programy do różnych usług
sieciowych, np. proftpd do usługi ftp. ``inetd`` nasłuchuje na odpowiednich
portach i w momencie nawiązania połączenia uruchamia program właściwy usłudze
z deskryptorami 0 i 1 ustawionymi tak, że program wysyła dane przez sieć
pisząc na standardowe wyjście a odczytuje dane czytając ze standardowego
wejścia. Niegdyś to podejście było zdecydowanie bardziej popularne niż dziś,
choć wciąż demon ten jest powszechny.

Piszemy exploita
----------------

exploit - potoczna nazwa na program który wykorzysta wadę innego programu.

Jeżeli jesteśmy w stanie wytropić sytuację, która pozwala na dowolne
przekroczenie rozmiaru bufora, to możemy pozwolić sobie na takie nadpisanie
adresu powrotu, żeby program zrobił to, czego chce atakujący.

Dla uproszczenia przyjmijmy, że mamy do czynienia z takim kodem (``server.c``)::

    void test()
    {
       char buf[4];
       gets(buf);
    }

    int main()
    {
       while (1) {
          test();
          printf("hello\n");
       }
       return 0;
    }

Przyjmujemy, że kod ten jest uruchomiony poprzez inetd. Naszym celem będzie
uzyskanie wszystkiego tego, co może użytkownik, w którego imieniu działa ten
program.

Szkic tego, co napiszemy:

- prześlemy kod do wykonania (tzw. payload)
- oprócz payload-a prześlemy takie dane, żeby zamiast powrotu z funkcji ``test()``
  wykonany został payload

Problemy:

- sprawdzić jak dużo śmieci trzeba wstawić przed sfingowany adres powrotu w
  trefnym komunikacie żeby trafić w odpowiednie miejsce na stosie
- dowiedzieć się, czym nadpisać adres powrotu, żeby skoczyć do payload'a
- napisać payload który zrobi coś sensownego

Dowiedzieć się gdzie jest adres powrotu, mając kod źródłowy, jest łatwo -
wystarczy policzyć mając na uwadze jak wygląda wołanie funkcji na i386. Gdy
kodu nie ma, można to zrobić robiąc zrzut pamięci (stosu) i od końca stosu
(jest znany, bo znany jest rejestr SP) poszukać wyrównanych do 4 bajtów
liczb, które wskazują na obszar pamięci w którym odwzorowany jest kod
programu.

Większy problem stanowi dowiedzenie się gdzie skoczyć, ponieważ:

- adres stosu przyznawany jest przez system operacyjny
- na pierwszy rzut oka nie bardzo wiadomo, co jest na tym stosie poniżej
  funkcji ``main``
- nawet jeżeli czytając kod libc i jądra dowiemy się co i ile tego jest na
  stosie poniżej funkcji main, to okaże się, że nie jest to stała liczba, bo
  zależy np. od:

  - rozmiaru argumentów przekazanych do programu
  - środowiska

Szczęśliwie, duża część systemów ma adres początku stosu zawsze taki sam -
bliski końca przestrzeni wirtualnej procesu, więc wahania położenia tego
bufora nie mogą być bardzo duże - zależą głównie od środowiska i argumentów
programu. Stąd też wahania adresu bufora da się sensownie oszacować -
wystarczy uruchomić program z pustym środowiskiem w katalogu /, bez
argumentów i sprawdzić adres dowolnej zmiennej lokalnej. Prawie na pewno nie
zdarzy się sytuacja, że stos pod funkcją main będzie większy. Mamy więc
jedno ograniczenie, a jako drugie należy przyjąć sensowne ograniczenie na
środowisko i argumenty.

Jeżeli stworzymy zatem taką sytuację na stosie:

=============================== ====================
Przed atakiem                   Po ataku
=============================== ====================
?                               payload
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
?                               NOP
------------------------------- --------------------
adres powrotu                   trefny adres powrotu
------------------------------- --------------------
opcjonalnie zachowane rejestry  śmieci
------------------------------- --------------------
bufor                           śmieci
=============================== ====================

(NOP odpowiada jakiejś operacji która nic nie robi)

to wystarczy, że trefny adres powrotu wskaże dowolną instrukcję NOP. Jeżeli
będzie ich wystarczająco dużo, to możemy w ten sposób zniwelować wahania
adresu bufora. Ta technika, czyli wstawianie w bufor dużej liczby NOP-ów
nazywa się nop-slide, ponieważ mówiąc obrazowo, ześlizgujemy się po NOP-ach do
payload'a.

Technikalia
-----------

Wszystkie technikalia zostały pokazane na przykładzie systemu NetBSD, żeby
zadaniem mogło być zrealizowanie tego pod Linuksem. Używane narzędzia są albo
takie same jak pod Linuksem albo prawie takie same, więc z dokładnością do
szczegółów nie powinno to stanowić przeszkody.

Narzędzia:

- ``objdump``: program deasemblujący skompilowane programy - przyda się do
  analizy, zwłaszcza z flagą ``-d``
- ``ulimit``: program zarządający limitami użytkownika - tylko po to aby
  poprosić jądro o robienie zrzutów pamięci (core dump) w przypadku kiedy
  program się wysypie - przydatne w debugowaniu (flaga ``-c``)
- ``gdb``: debugowanie z możliwością wczytania zrzutu pamięci
- ``gcc``: do kompilacji programów w tym payloada
- ``/proc/self/maps``: ten plik w linuksie pokazuje mapowania pamięci procesu, co
  pozwala przekonać się gdzie zaczyna się stos
- ``netcat`` (``nc``): program który posłuży nam do przesłania exploita przez sieć


Implementacja krok po kroku
---------------------------

Najprostszym i najbardziej efektownym payloadem będzie uruchomienie powłoki,
czyli wykonanie ``execve``. Ponieważ uruchamiany program dziedziczy deskryptory,
a program uruchomiony w inetd używa deskryptorów 0, 1 i 2 do komunikacji
przez sieć, to na skutek zawołania ``execve`` osiągniemy efekt podobny do zdalnej
powłoki.

Jako że nie jest jasne gdzie znajduje się PLT (bo zależy to od kompilatora i
bardzo drobnych zmian w kodzie) a tym bardziej gdzie zamapowany
jest kod biblioteki libc, lepiej wywoływać syscalle ręcznie - z pominięciem
opakowań dostarczanych przez bibliotekę standardową.

Sposób można znaleźć w dokumentacji systemu operacyjnego albo czytając jego
kod, najszybciej jednak chyba zrobić to kompilując statycznie program
wywołujący interesującego nas syscalla. Załączony plik exec.c po
skompilowaniu do exec należy obejrzeć za pomocą objdump -d. W przypadku
NetBSD widać, że wywołanie syscalla wymaga położenia na stos argumentów,
adresu powrotu, wpisania do AX numeru ``0x3b`` po czym zawołaniu przerwania
``0x80``.

W Linuksie wywołanie syscalla jest bardziej skomplikowane, ponieważ ze
względu na zarówno potrzebę binarnej kompatybilności ze starymi wersjami
jądra jak i chęć wykorzystania nowszych sposobów wykonywania syscalli,
zastosowano tam jeszcze jedną warstwę pośrednią - VDSO (virtual dynamically
shared object) czyli coś w stylu biblioteki dzielonej, która nie ma swojego
odzwierciedlenia na dysku. Zawiera ona kod (specyficzny dla konkretnej wersji
jądra) za pomocą którego wywoływane są syscalle. Biblioteka ta jest
władowywana w przestrzeń adresową każdego procesu (widać to w pliku
/proc/self/maps). Żeby wywołać syscalla należy zatem albo odwołać się do tej
biblioteki albo zobaczyć jaki ma ona kod. W nowszych jądrach biblioteka ta
jest ładowana pod przypadkowy adres, więc łatwiej sprawdzić kod. Najprościej
zrobić to wykonując objdump -d na tymże kodzie. Aby się do niego dostać
wystarczy napisać program, który zajrzy do /proc/self/maps, przeczyta gdzie
jest VDSO i zrzuci ten fragment na dysk. Można posłużyć się załączonym
programikiem ``dump_vdso.c``. (``make show-vdso``)

Wiedząc już jak wykonać syscall'a należy napisać programik w asemblerze,
który wykona ``execve`` na ``/bin/sh``.

Przykład (dla NetBSD) jest w pliku ``payload.s``.

Kod wykonywalny tego programu będzie naszym payloadem. Za pomocą make
show-payload można zobaczyć ten kod w formie dogodnej do zapisania w C.

Plik ``demo.c`` pokazuje jak można bezpośrednio przekazać sterowanie do tego kodu
(funkcja ``brute_force``) oraz jak nadpisać adres powrotu adresem payload'a.
Użyty tam adres jest wyłącznie skutkiem policzenia tego co jest na stosie
zgodnie z konwencją wołania podaną na początku.

Ostatnią rzeczą jest dostarczenie payload'a do programu z zewnątrz razem z
trefnym adresem powrotu i NOP-slidem. Położenie adresu w buforze wynika
bezpośrednio z przykładu demo.c. Sam adres natomiast został sprawdzony
eksperymentalnie poprzez sprawdzenie adresu zmiennej lokalnej w funkcji
``main()``.

Można obejrzeć to w pliku ``exploit.c``. Program ten, po wysłaniu trefnych
danych, wkonuje exec na program cat aby można było zademonstrować jego
działanie pisząc::

    ./exploit | ./server

Atak przez sieć
---------------

Aby osiągnąć ten sam efekt przez sieć (inetd) należy trochę poeksperymentować
z rozmiarem bufora (wielkością NOP-slide'a) i adresem pod który skaczemy.
Następnie wystarczy użyć netcata (polecenie nc) do interakcji ze zdalnie
uruchomionym serwerem, czyli później powłoką. W tym celu należy odpalić::

    ./exploit | nc adres_serwera port

Jeżeli wszystko dobrze pójdzie to efektem będzie wykorzystanie luki
20-linijkowego programu do przejęcia kontroli nad zdalnym komputerem.


Morał
-----

Na powyższym przykładzie widać jak bardzo niebezpiecznym jest niechlujne
programowanie. Pomimo tego, że jest to przykład na potrzeby przedmiotu, to
mechanizm jest powszechny, stosowany i wszechobecny. Raporty bezpieczeństwa z
portali internetowych typu Secunia to potwierdzają.

Czy można jakoś się przed tym bronić? Jest wiele metod, niestety jedynie
utrudniają one pracę hakerom a nie uniemożliwiają:

- randomizacja stosu (początek stosu jest w każdym procesie gdzie indziej)
- NX bit (nowsze procesory pozwlają na oznaczenie fragmentu przestrzeni
  wirtualnej (stosu) jako Non-eXecutable, co spowoduje błąd przy próbie
  uruchomienia payload'a
- gcc ma opcję ``-fstack-protector``, która powoduje, że gcc przy rozpoczynaniu
  wykonywania każdej funkcji umieszcza na stosie "strażnika" czyli z góry
  określony numerek, który jest sprawdzany przed wyjściem z funkcji czy nie
  został zmieniony
- poważne firewall'e wykrywają NOP-slide'y w pakietach i odrzucają je


Wskazówki
---------

- aby wyłączyć randomizację stosu należy zmienić ustawienia jądra::

      sysctl -w kernel.randomize_va_space=0

- aby dodać do inetd serwer udający ftp na porcie 21 należy dodać linijkę::

      ftp     stream  tcp     nowait  root    /root/server

.. Autor: Marek Dopiera <dopiera (at) mimuw (dot) edu (dot) pl>
